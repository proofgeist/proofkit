#!/usr/bin/env bun

/**
 * OData Metadata to TypeScript Table Occurrence Generator
 *
 * This script parses OData metadata XML files and generates TypeScript code
 * with fmTableOccurrence definitions using navigationPaths
 * for use with the fmodata package.
 *
 * Usage:
 *   bun scripts/typegen-starter.ts <input.xml> <output-folder>
 *
 * Example:
 *   bun scripts/typegen-starter.ts tests/fixtures/metadata.xml output/
 *
 * Features:
 * - Automatically maps OData types (Edm.String, Edm.Decimal, etc.) to Zod types
 * - Identifies key fields from Key elements and ensures they're non-nullable
 * - Marks calculation fields as readOnly
 * - Handles nullable fields with .nullable()
 * - Extracts FileMaker field IDs (FMFID) and table IDs (FMTID)
 * - Smart ID field detection (prioritizes @AutoGenerated fields or fields with "id" in name)
 * - Generates navigation relationships via navigationPaths with type-safe string refs
 * - Outputs one file per table with dynamic imports based on used field builders
 */

import { mkdir, readFile, writeFile } from "node:fs/promises";
import { join, resolve } from "node:path";
import { XMLParser } from "fast-xml-parser";

// Map OData types to field builder functions
function mapODataTypeToFieldBuilder(edmType: string): string {
  switch (edmType) {
    case "Edm.String":
      return "textField()";
    case "Edm.Decimal":
    case "Edm.Int32":
    case "Edm.Int64":
    case "Edm.Double":
      return "numberField()";
    case "Edm.Boolean":
      return "numberField().outputValidator(z.coerce.boolean())";
    case "Edm.Date":
      return "dateField()"; // ISO date string
    case "Edm.DateTimeOffset":
      return "timestampField()"; // ISO datetime string
    case "Edm.Binary":
      return "containerField()"; // base64 encoded
    default:
      return "textField()"; // Default to textField for unknown types
  }
}

interface FieldMetadata {
  $Type: string;
  $Nullable?: boolean;
  "@FieldID": string;
  "@Calculation"?: boolean;
  "@Global"?: boolean;
  "@Org.OData.Core.V1.Permissions"?: string;
  $DefaultValue?: string;
  "@AutoGenerated"?: boolean;
  "@Index"?: boolean;
  "@VersionID"?: boolean;
}

interface NavigationProperty {
  Name: string;
  Type: string; // e.g., "Collection(com.filemaker.odata.WebData.fmp12.Work_Orders_)"
}

interface EntityType {
  Name: string;
  "@TableID": string;
  $Key?: string[];
  Properties: Map<string, FieldMetadata>;
  NavigationProperties: NavigationProperty[];
}

interface EntitySet {
  Name: string;
  EntityType: string; // Full type name like "com.filemaker.odata.WebData.fmp12.Addresses_"
}

interface GeneratedTO {
  varName: string;
  code: string;
  navigation: string[]; // Array of target TO names
  usedFieldBuilders: Set<string>; // Track which field builders are used
  needsZod: boolean; // Whether z.coerce.boolean() is used
}

// Regex patterns
const COLLECTION_MATCH_REGEX = /Collection\(([^)]+)\)/;
const ENTITY_TYPE_NAME_REGEX = /\.([^.]+)$/;

function extractEntityTypeNameFromType(typeString: string): string | null {
  // Extract entity type name from Type like "Collection(com.filemaker.odata.WebData.fmp12.Work_Orders_)"
  // Returns "Work_Orders_"
  // Pattern: Collection(namespace.EntityTypeName) -> extract EntityTypeName
  const collectionMatch = typeString.match(COLLECTION_MATCH_REGEX);
  if (collectionMatch) {
    const fullType = collectionMatch[1];
    // Extract the last part after the last dot (e.g., "com.filemaker.odata.WebData.fmp12.Work_Orders_" -> "Work_Orders_")
    const parts = fullType.split(".");
    return parts.at(-1) || null;
  }
  // Try without Collection wrapper - extract last part after last dot
  const parts = typeString.split(".");
  return parts.at(-1) ?? null;
}

function generateTableOccurrence(
  entitySetName: string,
  entityType: EntityType,
  entityTypeToSetMap: Map<string, string>,
): GeneratedTO {
  const fmtId = entityType["@TableID"];
  const keyFields = entityType.$Key || [];
  const fields = entityType.Properties;
  const readOnlyFields: string[] = [];
  const navigationTargets: string[] = [];
  const usedFieldBuilders = new Set<string>();
  let needsZod = false;

  // Process navigation properties
  for (const navProp of entityType.NavigationProperties) {
    const targetEntityTypeName = extractEntityTypeNameFromType(navProp.Type);
    if (targetEntityTypeName) {
      const targetEntitySet = entityTypeToSetMap.get(targetEntityTypeName);
      if (targetEntitySet) {
        navigationTargets.push(targetEntitySet);
      }
    }
  }

  // Determine read-only fields
  for (const [fieldName, metadata] of fields.entries()) {
    if (
      metadata["@Calculation"] ||
      metadata["@Global"] ||
      metadata["@Org.OData.Core.V1.Permissions"]?.includes("Read")
    ) {
      readOnlyFields.push(fieldName);
    }
  }

  // Determine the id field
  let _idField: string;
  if (keyFields.length > 0) {
    // Use the first key field
    _idField = keyFields[0];
  } else {
    // Find a suitable ID field: look for auto-generated fields or fields with "id" in the name
    const fieldNames = Array.from(fields.keys());
    const autoGenField = fieldNames.find((name) => fields.get(name)?.["@AutoGenerated"]);
    const idFieldName = fieldNames.find(
      (name) => name.toLowerCase().includes("_id") || name.toLowerCase().endsWith("id") || name.toLowerCase() === "id",
    );
    _idField = autoGenField || idFieldName || fieldNames[0];
  }

  // Generate field builder definitions
  const fieldLines: string[] = [];
  const fieldEntries = Array.from(fields.entries());
  for (let i = 0; i < fieldEntries.length; i++) {
    const [fieldName, metadata] = fieldEntries[i];
    const fieldBuilder = mapODataTypeToFieldBuilder(metadata.$Type);

    // Track which field builders are used
    if (fieldBuilder.includes("textField()")) {
      usedFieldBuilders.add("textField");
    } else if (fieldBuilder.includes("numberField()")) {
      usedFieldBuilders.add("numberField");
    } else if (fieldBuilder.includes("dateField()")) {
      usedFieldBuilders.add("dateField");
    } else if (fieldBuilder.includes("timestampField()")) {
      usedFieldBuilders.add("timestampField");
    } else if (fieldBuilder.includes("containerField()")) {
      usedFieldBuilders.add("containerField");
    }

    // Track if z.coerce.boolean() is used
    if (fieldBuilder.includes("z.coerce.boolean()")) {
      needsZod = true;
    }

    const isKeyField = keyFields.includes(fieldName);
    // Only add .notNull() if explicitly marked as Nullable="false" in XML
    // metadata.$Nullable is false only if Nullable="false" was in XML, otherwise it's true (nullable by default)
    const isExplicitlyNotNullable = metadata.$Nullable === false;
    const isReadOnly = readOnlyFields.includes(fieldName);
    const isLastField = i === fieldEntries.length - 1;

    let line = `    ${JSON.stringify(fieldName)}: ${fieldBuilder}`;

    // Chain methods: primaryKey, readOnly, notNull, entityId
    if (isKeyField) {
      line += ".primaryKey()";
    }
    if (isReadOnly) {
      line += ".readOnly()";
    }
    // Only add .notNull() if explicitly marked as Nullable="false" in XML
    // Key fields are handled by primaryKey() which already makes them not null
    if (isExplicitlyNotNullable && !isKeyField) {
      line += ".notNull()";
    }
    if (metadata["@FieldID"]) {
      line += `.entityId(${JSON.stringify(metadata["@FieldID"])})`;
    }

    // Add comma if not the last field
    if (!isLastField) {
      line += ",";
    }

    fieldLines.push(line);
  }

  const varName = entitySetName.replace(/[^a-zA-Z0-9_]/g, "_");

  // Build options object
  const optionsParts: string[] = [];
  if (fmtId) {
    optionsParts.push(`entityId: ${JSON.stringify(fmtId)}`);
  }
  // Always include navigationPaths, even if empty
  const navPaths = navigationTargets.map((n) => JSON.stringify(n)).join(", ");
  optionsParts.push(`navigationPaths: [${navPaths}]`);

  const optionsSection = optionsParts.length > 0 ? `, {\n${optionsParts.map((p) => `  ${p}`).join(",\n")}\n}` : "";

  const code = `export const ${varName} = fmTableOccurrence(${JSON.stringify(entitySetName)}, {
${fieldLines.join("\n")}
}${optionsSection});`;

  return {
    varName,
    code,
    navigation: navigationTargets,
    usedFieldBuilders,
    needsZod,
  };
}

function ensureArray<T>(value: T | T[] | undefined): T[] {
  if (!value) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}

function parseXMLMetadata(xmlContent: string): {
  entityTypes: Map<string, EntityType>;
  entitySets: Map<string, EntitySet>;
  namespace: string;
} {
  const entityTypes = new Map<string, EntityType>();
  const entitySets = new Map<string, EntitySet>();
  let namespace = "";

  // Parse XML using fast-xml-parser
  const parser = new XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: "@_",
    textNodeName: "#text",
    parseAttributeValue: true,
    trimValues: true,
    parseTrueNumberOnly: false,
    arrayMode: false,
  });

  const parsed = parser.parse(xmlContent);

  // Navigate to Schema element
  const edmx = parsed["edmx:Edmx"] || parsed.Edmx;
  if (!edmx) {
    throw new Error("No Edmx element found in XML");
  }

  const dataServices = edmx["edmx:DataServices"] || edmx.DataServices;
  if (!dataServices) {
    throw new Error("No DataServices element found in XML");
  }

  const schema = ensureArray(dataServices.Schema)[0];
  if (!schema) {
    throw new Error("No Schema element found in XML");
  }

  namespace = schema["@_Namespace"] || schema.Namespace || "";

  // Extract EntityTypes
  const entityTypeList = ensureArray(schema.EntityType);
  for (const entityTypeEl of entityTypeList) {
    const entityTypeName = entityTypeEl["@_Name"] || entityTypeEl.Name;
    if (!entityTypeName) {
      continue;
    }

    // Get TableID from Annotation
    let tableId = "";
    const annotations = ensureArray(entityTypeEl.Annotation);
    for (const ann of annotations) {
      const term = ann["@_Term"] || ann.Term;
      if (term === "com.filemaker.odata.TableID") {
        tableId = ann["@_String"] || ann.String || "";
        break;
      }
    }

    // Get Key fields
    const keyFields: string[] = [];
    if (entityTypeEl.Key) {
      const propertyRefs = ensureArray(entityTypeEl.Key.PropertyRef);
      for (const propRef of propertyRefs) {
        const name = propRef["@_Name"] || propRef.Name;
        if (name) {
          keyFields.push(name);
        }
      }
    }

    // Extract Properties
    const properties = new Map<string, FieldMetadata>();
    const propertyList = ensureArray(entityTypeEl.Property);
    for (const propEl of propertyList) {
      const propName = propEl["@_Name"] || propEl.Name;
      if (!propName) {
        continue;
      }

      const propType = propEl["@_Type"] || propEl.Type || "";
      // Nullable is false only if explicitly set to "false", otherwise assume nullable
      // The parser converts "false" to boolean false, so check for both
      const nullableAttr = propEl["@_Nullable"] ?? propEl.Nullable;
      const isExplicitlyNotNullable = nullableAttr === "false" || nullableAttr === false;
      const defaultValue = propEl["@_DefaultValue"] || propEl.DefaultValue || undefined;

      // Get annotations
      let fieldId = "";
      let isCalculation = false;
      let isGlobal = false;
      let isAutoGenerated = false;
      let hasIndex = false;
      let isVersionId = false;
      let permissions: string | undefined;

      const propAnnotations = ensureArray(propEl.Annotation);
      for (const ann of propAnnotations) {
        const term = ann["@_Term"] || ann.Term;
        if (term === "com.filemaker.odata.FieldID") {
          fieldId = ann["@_String"] || ann.String || "";
        } else if (term === "com.filemaker.odata.Calculation") {
          isCalculation = ann["@_Bool"] === "true" || ann.Bool === "true";
        } else if (term === "com.filemaker.odata.Global") {
          isGlobal = ann["@_Bool"] === "true" || ann.Bool === "true";
        } else if (term === "com.filemaker.odata.AutoGenerated") {
          isAutoGenerated = ann["@_Bool"] === "true" || ann.Bool === "true";
        } else if (term === "com.filemaker.odata.Index") {
          hasIndex = ann["@_Bool"] === "true" || ann.Bool === "true";
        } else if (term === "com.filemaker.odata.VersionID") {
          isVersionId = ann["@_Bool"] === "true" || ann.Bool === "true";
        } else if (term === "Org.OData.Core.V1.Permissions") {
          const enumMember = ann.EnumMember;
          if (enumMember) {
            permissions = typeof enumMember === "string" ? enumMember : enumMember["#text"] || undefined;
          }
        }
      }

      properties.set(propName, {
        $Type: propType,
        $Nullable: !isExplicitlyNotNullable, // true if not explicitly set to false
        "@FieldID": fieldId,
        "@Calculation": isCalculation,
        "@Global": isGlobal,
        "@Org.OData.Core.V1.Permissions": permissions,
        $DefaultValue: defaultValue,
        "@AutoGenerated": isAutoGenerated,
        "@Index": hasIndex,
        "@VersionID": isVersionId,
      });
    }

    // Extract NavigationProperties
    const navigationProperties: NavigationProperty[] = [];
    if (entityTypeEl.NavigationProperty) {
      const navPropList = ensureArray(entityTypeEl.NavigationProperty);
      for (const navPropEl of navPropList) {
        const navName = navPropEl["@_Name"] || navPropEl.Name;
        const navType = navPropEl["@_Type"] || navPropEl.Type;
        if (navName && navType) {
          navigationProperties.push({
            Name: navName,
            Type: navType,
          });
        }
      }
    }

    entityTypes.set(entityTypeName, {
      Name: entityTypeName,
      "@TableID": tableId,
      $Key: keyFields,
      Properties: properties,
      NavigationProperties: navigationProperties,
    });
  }

  // Extract EntitySets from EntityContainer
  const entityContainer = ensureArray(schema.EntityContainer)[0];
  if (entityContainer) {
    const entitySetList = ensureArray(entityContainer.EntitySet);
    for (const entitySetEl of entitySetList) {
      const setName = entitySetEl["@_Name"] || entitySetEl.Name;
      const entityType = entitySetEl["@_EntityType"] || entitySetEl.EntityType;
      if (setName && entityType) {
        // Extract just the entity type name from the full type string
        // e.g., "com.filemaker.odata.WebData.fmp12.Addresses_" -> "Addresses_"
        const typeNameMatch = entityType.match(ENTITY_TYPE_NAME_REGEX);
        const entityTypeName = typeNameMatch ? typeNameMatch[1] : entityType;

        entitySets.set(setName, {
          Name: setName,
          EntityType: entityTypeName,
        });
      }
    }
  }

  return { entityTypes, entitySets, namespace };
}

function generateImports(usedFieldBuilders: Set<string>, needsZod: boolean): string {
  const fieldBuilderImports: string[] = [];

  // Always need fmTableOccurrence
  fieldBuilderImports.push("fmTableOccurrence");

  // Add only the field builders that are actually used
  if (usedFieldBuilders.has("textField")) {
    fieldBuilderImports.push("textField");
  }
  if (usedFieldBuilders.has("numberField")) {
    fieldBuilderImports.push("numberField");
  }
  if (usedFieldBuilders.has("dateField")) {
    fieldBuilderImports.push("dateField");
  }
  if (usedFieldBuilders.has("timestampField")) {
    fieldBuilderImports.push("timestampField");
  }
  if (usedFieldBuilders.has("containerField")) {
    fieldBuilderImports.push("containerField");
  }

  const imports = [`import { ${fieldBuilderImports.join(", ")} } from "@proofkit/fmodata"`];

  if (needsZod) {
    imports.push(`import { z } from "zod/v4"`);
  }

  return `${imports.join(";\n")};\n`;
}

function sanitizeFileName(name: string): string {
  // Convert to a safe filename
  return name.replace(/[^a-zA-Z0-9_]/g, "_");
}

async function generateFromMetadata(inputPath: string, outputFolder: string): Promise<void> {
  console.log(`Reading metadata from: ${inputPath}`);

  // Read and parse the metadata XML
  const xmlContent = await readFile(inputPath, "utf-8");
  const { entityTypes, entitySets, namespace: _namespace } = parseXMLMetadata(xmlContent);

  // Build a map from entity type name to entity set name
  const entityTypeToSetMap = new Map<string, string>();
  for (const [entitySetName, entitySet] of entitySets.entries()) {
    entityTypeToSetMap.set(entitySet.EntityType, entitySetName);
  }

  // Generate table occurrences for entity sets
  const generatedTOs: GeneratedTO[] = [];

  console.log(`\nFound ${entitySets.size} entity sets:`);
  for (const [entitySetName, entitySet] of entitySets.entries()) {
    const entityType = entityTypes.get(entitySet.EntityType);
    if (entityType) {
      const generated = generateTableOccurrence(entitySetName, entityType, entityTypeToSetMap);

      const navInfo = generated.navigation.length > 0 ? ` [nav: ${generated.navigation.join(", ")}]` : "";
      console.log(`  - ${entitySetName} (${entitySet.EntityType})${navInfo}`);

      generatedTOs.push(generated);
    }
  }

  // Create output directory
  console.log(`\nCreating output directory: ${outputFolder}`);
  await mkdir(outputFolder, { recursive: true });

  // Generate one file per table occurrence
  const exportStatements: string[] = [];

  for (const generated of generatedTOs) {
    const fileName = `${sanitizeFileName(generated.varName)}.ts`;
    const filePath = join(outputFolder, fileName);

    // Generate imports based on what's actually used in this file
    const imports = generateImports(generated.usedFieldBuilders, generated.needsZod);

    const fileContent = `${imports}
// ============================================================================
// Table Occurrence: ${generated.varName}
// ============================================================================

${generated.code}
`;

    await writeFile(filePath, fileContent, "utf-8");
    console.log(`  ✓ Generated ${fileName}`);

    // Collect export statement for index file
    exportStatements.push(`export { ${generated.varName} } from "./${sanitizeFileName(generated.varName)}";`);
  }

  // Generate index.ts file that exports all table occurrences
  const indexContent = `// ============================================================================
// Auto-generated index file - exports all table occurrences
// ============================================================================

${exportStatements.join("\n")}
`;

  const indexPath = join(outputFolder, "index.ts");
  await writeFile(indexPath, indexContent, "utf-8");
  console.log("  ✓ Generated index.ts");

  console.log(`\n✓ Generation complete! Generated ${generatedTOs.length} table occurrence files.`);
}

// Main execution
const args = process.argv.slice(2);

if (args.length < 2) {
  console.error("Usage: bun typegen-starter.ts <input.xml> <output-folder>");
  console.error("\nExample: bun typegen-starter.ts metadata.xml output/");
  process.exit(1);
}

const inputPath = resolve(args[0]);
const outputFolder = resolve(args[1]);

generateFromMetadata(inputPath, outputFolder).catch((error) => {
  console.error("Error:", error);
  process.exit(1);
});
