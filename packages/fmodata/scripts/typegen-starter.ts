#!/usr/bin/env bun

/**
 * OData Metadata to TypeScript Table Occurrence Generator
 *
 * This script parses OData metadata JSON files and generates TypeScript code
 * with defineBaseTable, defineTableOccurrence, and buildOccurrences definitions
 * for use with the fmodata package.
 *
 * Usage:
 *   bun scripts/typegen-starter.ts <input.json> <output.ts>
 *
 * Example:
 *   bun scripts/typegen-starter.ts tests/fixtures/sample-metadata.json output/occurrences.ts
 *
 * Features:
 * - Automatically maps OData types (Edm.String, Edm.Decimal, etc.) to Zod types
 * - Identifies key fields from $Key and ensures they're non-nullable
 * - Marks calculation fields as readOnly
 * - Handles nullable fields with .nullable()
 * - Extracts FileMaker field IDs (FMFID) and table IDs (FMTID)
 * - Smart ID field detection (prioritizes @AutoGenerated fields or fields with "id" in name)
 * - Generates navigation relationships via buildOccurrences with type-safe string refs
 */

import { readFile, writeFile } from "node:fs/promises";
import { resolve } from "node:path";

// Map OData types to Zod types
function mapODataTypeToZod(edmType: string): string {
  switch (edmType) {
    case "Edm.String":
      return "z.string()";
    case "Edm.Decimal":
    case "Edm.Int32":
    case "Edm.Int64":
    case "Edm.Double":
      return "z.number()";
    case "Edm.Boolean":
      return "z.boolean()";
    case "Edm.Date":
      return "z.string()"; // ISO date string
    case "Edm.DateTimeOffset":
      return "z.string()"; // ISO datetime string
    case "Edm.Binary":
      return "z.string()"; // base64 encoded
    default:
      return "z.unknown()";
  }
}

interface FieldMetadata {
  $Type: string;
  $Nullable?: boolean;
  "@FieldID": string;
  "@Calculation"?: boolean;
  "@Global"?: boolean;
  "@Org.OData.Core.V1.Permissions"?: string;
  $DefaultValue?: string;
  "@AutoGenerated"?: boolean;
  "@Index"?: boolean;
  "@VersionID"?: boolean;
}

interface NavigationProperty {
  $Kind: "NavigationProperty";
  $Type: string;
  $Collection?: boolean;
}

interface EntityType {
  $Kind: "EntityType";
  "@TableID": string;
  $Key?: string[];
  [fieldName: string]: any;
}

interface Metadata {
  $Version: string;
  "@ServerVersion": string;
  [namespace: string]: any;
}

interface GeneratedTO {
  varName: string;
  code: string;
  navigation: string[]; // Array of target TO names
}

function generateTableOccurrence(
  entityName: string,
  entityType: EntityType,
  namespace: string,
  entityTypeToSetMap: Map<string, string>,
): GeneratedTO {
  const fmtId = entityType["@TableID"];
  const keyFields = entityType.$Key || [];
  const fields: Record<string, FieldMetadata> = {};
  const readOnlyFields: string[] = [];
  const navigationTargets: string[] = [];

  // Extract field definitions and navigation properties
  for (const [key, value] of Object.entries(entityType)) {
    if (
      key.startsWith("$") ||
      key.startsWith("@") ||
      typeof value !== "object" ||
      !value.$Type
    ) {
      continue;
    }

    // Check if it's a navigation property
    if (value.$Kind === "NavigationProperty") {
      const navProp = value as NavigationProperty;
      // Extract the target entity type from the $Type (e.g., "WebData.fmp12.Addresses_" -> "Addresses_")
      const targetEntityType = navProp.$Type.replace(`${namespace}.`, "");
      const targetEntitySet = entityTypeToSetMap.get(targetEntityType);
      if (targetEntitySet) {
        navigationTargets.push(targetEntitySet);
      }
      continue;
    }

    // Regular field
    fields[key] = value as FieldMetadata;

    // Check if field is calculation or read-only
    if (
      value["@Calculation"] ||
      value["@Global"] ||
      value["@Org.OData.Core.V1.Permissions"]?.includes("Read")
    ) {
      readOnlyFields.push(key);
    }
  }

  // Determine the id field
  let idField: string;
  if (keyFields.length > 0) {
    // Use the first key field
    idField = keyFields[0];
  } else {
    // Find a suitable ID field: look for auto-generated fields or fields with "id" in the name
    const fieldNames = Object.keys(fields);
    const autoGenField = fieldNames.find(
      (name) => fields[name]["@AutoGenerated"],
    );
    const idFieldName = fieldNames.find(
      (name) =>
        name.toLowerCase().includes("_id") ||
        name.toLowerCase().endsWith("id") ||
        name.toLowerCase() === "id",
    );
    idField = autoGenField || idFieldName || fieldNames[0];
  }

  // Generate schema object
  const schemaLines: string[] = [];
  const fieldEntries = Object.entries(fields);
  for (let i = 0; i < fieldEntries.length; i++) {
    const [fieldName, metadata] = fieldEntries[i];
    const zodType = mapODataTypeToZod(metadata.$Type);
    const isKeyField = keyFields.includes(fieldName);
    const isNullable = metadata.$Nullable === true && !isKeyField;
    const isLastField = i === fieldEntries.length - 1;

    let line = `      ${JSON.stringify(fieldName)}: ${zodType}`;
    if (isNullable) {
      line += ".nullable()";
    }

    // Add comma if not the last field
    if (!isLastField) {
      line += ",";
    }

    // Add comment for key fields or special types
    const comments: string[] = [];
    if (isKeyField) {
      comments.push("Key field - never null");
    } else if (!metadata.$Nullable) {
      comments.push("Not nullable");
    }
    if (metadata["@AutoGenerated"]) {
      comments.push("Auto-generated");
    }

    if (comments.length > 0) {
      line += ` // ${comments.join(", ")}`;
    }

    schemaLines.push(line);
  }

  // Generate fmfIds object
  const fmfIdsLines: string[] = [];
  const fmfFieldEntries = Object.entries(fields);
  for (let i = 0; i < fmfFieldEntries.length; i++) {
    const [fieldName, metadata] = fmfFieldEntries[i];
    const isLastField = i === fmfFieldEntries.length - 1;
    const comma = isLastField ? "" : ",";
    fmfIdsLines.push(
      `      ${JSON.stringify(fieldName)}: ${JSON.stringify(metadata["@FieldID"])}${comma}`,
    );
  }

  // Generate the table occurrence
  const readOnlyConfig =
    readOnlyFields.length > 0
      ? `,\n    readOnly: [${readOnlyFields.map((f) => JSON.stringify(f)).join(", ")}] as const`
      : "";

  const varName = entityName.replace(/[^a-zA-Z0-9_]/g, "_");

  const code = `// ${entityName} table occurrence
const _${varName} = defineTableOccurrence({
  fmtId: ${JSON.stringify(fmtId)},
  name: ${JSON.stringify(entityName)} as const,
  baseTable: defineBaseTable({
    schema: {
${schemaLines.join("\n")}
    },
    idField: ${JSON.stringify(idField)},
    fmfIds: {
${fmfIdsLines.join("\n")}
    }${readOnlyConfig}
  }),
});`;

  return {
    varName,
    code,
    navigation: navigationTargets,
  };
}

async function generateFromMetadata(
  inputPath: string,
  outputPath: string,
): Promise<void> {
  console.log(`Reading metadata from: ${inputPath}`);

  // Read and parse the metadata JSON
  const metadataContent = await readFile(inputPath, "utf-8");
  const metadata: Metadata = JSON.parse(metadataContent);

  // Find the namespace (skip $Version and @ServerVersion)
  const namespace = Object.keys(metadata).find(
    (key) => !key.startsWith("$") && !key.startsWith("@"),
  );

  if (!namespace) {
    throw new Error("No namespace found in metadata");
  }

  const namespaceData = metadata[namespace];
  const entityTypes: Record<string, EntityType> = {};
  const entitySets: Record<string, string> = {};

  // Extract entity types and entity sets
  for (const [key, value] of Object.entries(namespaceData)) {
    if (typeof value === "object" && value !== null) {
      const obj = value as any;
      if (obj.$Kind === "EntityType") {
        entityTypes[key] = value as EntityType;
      } else if (obj.$Kind === "EntitySet") {
        // EntitySet references an EntityType
        const typeName = obj.$Type?.replace(`${namespace}.`, "");
        if (typeName) {
          entitySets[key] = typeName;
        }
      }
    }
  }

  // Build a map from entity type name to entity set name
  const entityTypeToSetMap = new Map<string, string>();
  for (const [entitySetName, entityTypeName] of Object.entries(entitySets)) {
    entityTypeToSetMap.set(entityTypeName, entitySetName);
  }

  // Generate table occurrences for entity sets
  const generatedTOs: GeneratedTO[] = [];

  console.log(`\nFound ${Object.keys(entitySets).length} entity sets:`);
  for (const [entitySetName, entityTypeName] of Object.entries(entitySets)) {
    const entityType = entityTypes[entityTypeName];
    if (entityType) {
      const generated = generateTableOccurrence(
        entitySetName,
        entityType,
        namespace,
        entityTypeToSetMap,
      );

      const navInfo =
        generated.navigation.length > 0
          ? ` [nav: ${generated.navigation.join(", ")}]`
          : "";
      console.log(`  - ${entitySetName} (${entityTypeName})${navInfo}`);

      generatedTOs.push(generated);
    }
  }

  // Generate the base TO definitions (Phase 1)
  const baseDefinitions = generatedTOs.map((to) => to.code).join("\n\n");

  // Generate the buildOccurrences call (Phase 2)
  const varNames = generatedTOs.map((to) => to.varName);
  const baseVarNames = varNames.map((v) => `_${v}`);

  // Build navigation config
  const navConfigLines: string[] = [];
  for (const to of generatedTOs) {
    if (to.navigation.length > 0) {
      const navTargets = to.navigation.map((n) => JSON.stringify(n)).join(", ");
      navConfigLines.push(
        `    ${JSON.stringify(to.varName)}: [${navTargets}],`,
      );
    }
  }

  const navConfigSection =
    navConfigLines.length > 0
      ? `\n  navigation: {\n${navConfigLines.join("\n")}\n  },`
      : "";

  // Generate the complete TypeScript file
  const output = `import { defineBaseTable, defineTableOccurrence, buildOccurrences } from "@proofkit/fmodata";
import { z } from "zod/v4";

// ============================================================================
// Phase 1: Define all TableOccurrences (without navigation)
// ============================================================================

${baseDefinitions}

// ============================================================================
// Phase 2: Build final TableOccurrences with navigation relationships
// ============================================================================

export const [${varNames.join(", ")}] = buildOccurrences({
  occurrences: [${baseVarNames.join(", ")}],${navConfigSection}
});

// Export as array for use with database()
export const occurrences = [${varNames.join(", ")}];
`;

  console.log(`Writing output to: ${outputPath}`);
  await writeFile(outputPath, output, "utf-8");
  console.log("âœ“ Generation complete!");
}

// Main execution
const args = process.argv.slice(2);

if (args.length < 2) {
  console.error("Usage: bun typegen-starter.ts <input.json> <output.ts>");
  console.error(
    "\nExample: bun typegen-starter.ts sample-metadata.json sample-occurances.ts",
  );
  process.exit(1);
}

const inputPath = resolve(args[0]);
const outputPath = resolve(args[1]);

generateFromMetadata(inputPath, outputPath).catch((error) => {
  console.error("Error:", error);
  process.exit(1);
});
