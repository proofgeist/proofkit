# Refactoring Summary: Decoupling Table Schema from Client

## Overview

This refactoring separates table schema definitions from execution context (connection details), making the architecture more composable and suitable for code generation.

## Key Changes

### 1. New `ExecutionContext` Interface

```typescript
export interface ExecutionContext {
  _makeRequest(url: string, options?: RequestInit): Promise<any>;
}
```

**Purpose**: Defines the contract for executing requests. `FileMakerOData` implements this interface.

**Benefits**:

- Enables dependency injection
- Makes testing easier (can create mock implementations)
- Allows different execution strategies

### 2. New `TableDefinition` Class

```typescript
export class TableDefinition<Schema extends z.ZodObject = any> {
  public readonly name: string;
  public readonly schema?: Schema;

  constructor(config: { name: string; schema?: Schema }) {
    this.name = config.name;
    this.schema = config.schema;
  }
}
```

**Purpose**: Holds pure table metadata (name and schema) without any connection details.

**Benefits**:

- Completely decoupled from database name and connection
- Can be generated by code generators
- Reusable across different databases and servers
- Uses named arguments for clarity

### 3. Refactored `Table` Class

**Before**:

```typescript
class Table<Schema, T> {
  constructor({
    databaseName,
    name,
    client,
    schema,
  }: {
    databaseName: string;
    name: string;
    client: FileMakerOData;
    schema?: Schema;
  }) {
    // ...
  }
}
```

**After**:

```typescript
export class Table<Schema, T> {
  constructor(config: {
    definition: TableDefinition<Schema>;
    databaseName: string;
    context: ExecutionContext;
  }) {
    // ...
  }
}
```

**Changes**:

- Now accepts a `TableDefinition` instead of raw name/schema
- Accepts `ExecutionContext` instead of concrete `FileMakerOData` client
- Uses named arguments pattern
- Exported for direct usage

### 4. Refactored `QueryBuilder` and `RecordBuilder`

**Before**:

```typescript
constructor({
  databaseName,
  tableName,
  client,
}: {
  databaseName: string;
  tableName: string;
  client: FileMakerOData;
})
```

**After**:

```typescript
constructor(config: {
  definition: TableDefinition;
  databaseName: string;
  context: ExecutionContext;
})
```

**Changes**:

- Now use `TableDefinition` instead of string `tableName`
- Accept `ExecutionContext` instead of concrete client
- Access table name via `definition.name`
- Use named arguments pattern

### 5. Updated `Database` Class

**Before**:

```typescript
table<Schema>(name: string, config?: { schema: Schema }) {
  return new Table<Schema>({
    databaseName: this.name,
    name,
    client: this.client,
    schema: config?.schema,
  });
}
```

**After**:

```typescript
table<Schema>(name: string, config?: { schema: Schema }) {
  const definition = new TableDefinition({ name, schema: config?.schema });
  return new Table<Schema>({
    definition,
    databaseName: this.name,
    context: this.context,
  });
}
```

**Changes**:

- Creates `TableDefinition` instances internally
- Passes `ExecutionContext` instead of concrete client
- Database name is provided at runtime, not stored in definition

## Architecture Diagram

```
Before:
┌─────────────────┐
│ FileMakerOData  │
│   (Client)      │
└────────┬────────┘
         │
         ├──► Database ──► Table (holds client reference)
         │                   │
         │                   ├──► QueryBuilder (holds client)
         │                   └──► RecordBuilder (holds client)
         │
         └──► Tightly coupled to connection details

After:
┌─────────────────┐
│ TableDefinition │  ← Pure metadata (can be generated)
│  (name, schema) │
└────────┬────────┘
         │
         │    ┌─────────────────┐
         │    │ ExecutionContext│  ← Interface for execution
         │    │   (FileMaker    │
         │    │    implements)  │
         │    └────────┬────────┘
         │             │
         └─────┬───────┘
               │
          ┌────▼─────┐
          │  Table   │ ← Composition of definition + context
          │          │
          ├──► QueryBuilder (uses definition + context)
          └──► RecordBuilder (uses definition + context)

Decoupled: Schema definitions separate from execution
```

## Backward Compatibility

✅ **The public API remains identical.**

Existing code continues to work without changes:

```typescript
const client = new FileMakerOData({ serverUrl, auth });
const db = client.database("MyDB");
const table = db.table("Users", { schema });
const results = await table.select("id", "name").execute();
```

## New Capabilities Enabled

### 1. Direct Table Instantiation

```typescript
const tableDef = new TableDefinition({
  name: "Users",
  schema: mySchema,
});

const table = new Table({
  definition: tableDef,
  databaseName: "MyDB",
  context: client,
});
```

### 2. Reuse Definitions Across Contexts

```typescript
const tableDef = new TableDefinition({ name: "Users", schema });

const table1 = new Table({
  definition: tableDef,
  databaseName: "DB1",
  context: client1,
});
const table2 = new Table({
  definition: tableDef,
  databaseName: "DB2",
  context: client2,
});
```

### 3. Mock Testing

```typescript
class MockContext implements ExecutionContext {
  async _makeRequest(url: string) {
    return { value: [{ id: 1, name: "Test" }] };
  }
}

const table = new Table({
  definition: tableDef,
  databaseName: "TestDB",
  context: new MockContext(),
});
```

### 4. Code Generation

```typescript
// Generated code (no connection details)
export const UsersTable = new TableDefinition({
  name: "Users",
  schema: z.object({
    id: z.number(),
    name: z.string(),
    email: z.string().email(),
  }),
});

// Runtime usage
const table = new Table({
  definition: UsersTable,
  databaseName: config.dbName,
  context: client,
});
```

## Files Modified

- ✅ `/packages/fmodata/src/index.ts` - Core refactoring
- ✅ `/packages/fmodata/tests/basic.test.ts` - Added new tests

## Files Created

- ✅ `/packages/fmodata/CODEGEN_EXAMPLE.md` - Code generation examples
- ✅ `/packages/fmodata/REFACTORING_SUMMARY.md` - This file

## Testing

New tests added:

1. ✅ Standalone `TableDefinition` creation
2. ✅ Using `TableDefinition` with `Table` class directly
3. ✅ Reusing definitions across different execution contexts

All existing tests pass without modification (backward compatible).

## Next Steps for Code Generation

1. Create a code generator that reads FileMaker metadata
2. Generate `TableDefinition` instances with full Zod schemas
3. Export definitions from a generated file
4. Users import and use generated definitions with their clients

## Benefits Summary

| Aspect          | Before                             | After                                |
| --------------- | ---------------------------------- | ------------------------------------ |
| **Coupling**    | Table tightly coupled to client    | Table uses interface abstraction     |
| **Reusability** | Table bound to single connection   | Table definition reusable everywhere |
| **Testing**     | Hard to mock (needs real client)   | Easy to mock (interface-based)       |
| **Code Gen**    | Must generate full Table instances | Generate pure TableDefinition        |
| **Clarity**     | Positional arguments               | Named arguments                      |
| **Composition** | Monolithic                         | Composable layers                    |

## Migration Impact

✅ **Zero breaking changes** - All existing code continues to work as-is.

The refactoring is a pure internal improvement that enables new use cases without affecting existing functionality.
