import { writeFile, mkdir } from "node:fs/promises";
import { join, resolve } from "node:path";
import fs from "fs-extra";
import type { ParsedMetadata, EntityType } from "./parseMetadata";
import { FmodataConfig } from "../types";

interface GeneratedTO {
  varName: string;
  code: string;
  navigation: string[];
  usedFieldBuilders: Set<string>;
  needsZod: boolean;
}

/**
 * Maps type override enum values to field builder functions from @proofkit/fmodata
 */
function mapTypeOverrideToFieldBuilder(
  typeOverride:
    | "text"
    | "number"
    | "boolean"
    | "fmBooleanNumber"
    | "date"
    | "timestamp"
    | "container",
): string {
  switch (typeOverride) {
    case "text":
      return "textField()";
    case "number":
      return "numberField()";
    case "boolean":
    case "fmBooleanNumber":
      return "numberField().outputValidator(z.coerce.boolean())";
    case "date":
      return "dateField()";
    case "timestamp":
      return "timestampField()";
    case "container":
      return "containerField()";
  }
}

/**
 * Maps OData types to field builder functions from @proofkit/fmodata
 */
function mapODataTypeToFieldBuilder(
  edmType: string,
  typeOverride?:
    | "text"
    | "number"
    | "boolean"
    | "fmBooleanNumber"
    | "date"
    | "timestamp"
    | "container",
): string {
  // If typeOverride is provided, use it instead of the inferred type
  if (typeOverride) {
    return mapTypeOverrideToFieldBuilder(typeOverride);
  }

  switch (edmType) {
    case "Edm.String":
      return "textField()";
    case "Edm.Decimal":
    case "Edm.Int32":
    case "Edm.Int64":
    case "Edm.Double":
      return "numberField()";
    case "Edm.Boolean":
      return "numberField().outputValidator(z.coerce.boolean())";
    case "Edm.Date":
      return "dateField()"; // ISO date string
    case "Edm.DateTimeOffset":
      return "timestampField()"; // ISO datetime string
    case "Edm.Binary":
      return "containerField()"; // base64 encoded
    default:
      return "textField()"; // Default to textField for unknown types
  }
}

/**
 * Extracts entity type name from Type string like "Collection(com.filemaker.odata.WebData.fmp12.Work_Orders_)"
 * Returns "Work_Orders_"
 */
function extractEntityTypeNameFromType(typeString: string): string | null {
  // Pattern: Collection(namespace.EntityTypeName) -> extract EntityTypeName
  const collectionMatch = typeString.match(/Collection\(([^)]+)\)/);
  if (collectionMatch && collectionMatch[1]) {
    const fullType = collectionMatch[1];
    // Extract the last part after the last dot
    const parts = fullType.split(".");
    return parts[parts.length - 1] ?? null;
  }
  // Try without Collection wrapper - extract last part after last dot
  const parts = typeString.split(".");
  return parts.length > 0 ? (parts[parts.length - 1] ?? null) : null;
}

/**
 * Generates a table occurrence definition for a single entity set
 */
function generateTableOccurrence(
  entitySetName: string,
  entityType: EntityType,
  entityTypeToSetMap: Map<string, string>,
  tableOverride?: NonNullable<FmodataConfig["tables"]>[number],
): GeneratedTO {
  const fmtId = entityType["@TableID"];
  const keyFields = entityType.$Key || [];
  const fields = entityType.Properties;
  const readOnlyFields: string[] = [];
  const navigationTargets: string[] = [];
  const usedFieldBuilders = new Set<string>();
  let needsZod = false;

  // Process navigation properties
  for (const navProp of entityType.NavigationProperties) {
    const targetEntityTypeName = extractEntityTypeNameFromType(navProp.Type);
    if (targetEntityTypeName) {
      const targetEntitySet = entityTypeToSetMap.get(targetEntityTypeName);
      if (targetEntitySet) {
        navigationTargets.push(targetEntitySet);
      }
    }
  }

  // Determine read-only fields
  for (const [fieldName, metadata] of fields.entries()) {
    if (
      metadata["@Calculation"] ||
      metadata["@Global"] ||
      metadata["@Org.OData.Core.V1.Permissions"]?.includes("Read")
    ) {
      readOnlyFields.push(fieldName);
    }
  }

  // Determine the id field (for reference, not used in generation)
  let idField: string;
  if (keyFields.length > 0) {
    // Use the first key field
    const firstKey = keyFields[0];
    if (!firstKey) {
      throw new Error("Key fields array is empty but length check passed");
    }
    idField = firstKey;
  } else {
    // Find a suitable ID field: look for auto-generated fields or fields with "id" in the name
    const fieldNames = Array.from(fields.keys());
    const autoGenField = fieldNames.find(
      (name) => fields.get(name)?.["@AutoGenerated"],
    );
    const idFieldName = fieldNames.find(
      (name) =>
        name.toLowerCase().includes("_id") ||
        name.toLowerCase().endsWith("id") ||
        name.toLowerCase() === "id",
    );
    const firstFieldName = fieldNames[0];
    if (!firstFieldName) {
      throw new Error("No fields found in entity type");
    }
    idField = autoGenField ?? idFieldName ?? firstFieldName;
  }

  // Build a field overrides map from the array for easier lookup
  type FieldOverrideType = Exclude<
    NonNullable<NonNullable<FmodataConfig["tables"]>[number]>["fields"],
    undefined
  >[number];
  const fieldOverridesMap = new Map<string, FieldOverrideType>();
  if (tableOverride?.fields) {
    for (const fieldOverride of tableOverride.fields) {
      if (fieldOverride?.fieldName) {
        fieldOverridesMap.set(fieldOverride.fieldName, fieldOverride);
      }
    }
  }

  // Generate field builder definitions
  const fieldLines: string[] = [];
  const fieldEntries = Array.from(fields.entries());

  // Filter out excluded fields and collect valid entries
  const validFieldEntries: Array<
    [string, typeof fields extends Map<infer K, infer V> ? V : never]
  > = [];
  for (const entry of fieldEntries) {
    if (!entry) continue;
    const [fieldName] = entry;
    const fieldOverride = fieldOverridesMap.get(fieldName);

    // Skip excluded fields
    if (fieldOverride?.exclude === true) {
      continue;
    }

    validFieldEntries.push(entry);
  }

  for (let i = 0; i < validFieldEntries.length; i++) {
    const entry = validFieldEntries[i];
    if (!entry) continue;
    const [fieldName, metadata] = entry;
    const fieldOverride = fieldOverridesMap.get(fieldName);

    // Apply typeOverride if provided, otherwise use inferred type
    const fieldBuilder = mapODataTypeToFieldBuilder(
      metadata.$Type,
      fieldOverride?.typeOverride as
        | "text"
        | "number"
        | "boolean"
        | "fmBooleanNumber"
        | "date"
        | "timestamp"
        | "container"
        | undefined,
    );

    // Track which field builders are used
    if (fieldBuilder.includes("textField()")) {
      usedFieldBuilders.add("textField");
    } else if (fieldBuilder.includes("numberField()")) {
      usedFieldBuilders.add("numberField");
    } else if (fieldBuilder.includes("dateField()")) {
      usedFieldBuilders.add("dateField");
    } else if (fieldBuilder.includes("timestampField()")) {
      usedFieldBuilders.add("timestampField");
    } else if (fieldBuilder.includes("containerField()")) {
      usedFieldBuilders.add("containerField");
    }

    // Track if z.coerce.boolean() is used
    if (fieldBuilder.includes("z.coerce.boolean()")) {
      needsZod = true;
    }

    const isKeyField = keyFields.includes(fieldName);
    // Only add .notNull() if explicitly marked as Nullable="false" in XML
    // metadata.$Nullable is false only if Nullable="false" was in XML, otherwise it's true (nullable by default)
    const isExplicitlyNotNullable = metadata.$Nullable === false;
    const isReadOnly = readOnlyFields.includes(fieldName);
    const isLastField = i === validFieldEntries.length - 1;

    let line = `    ${JSON.stringify(fieldName)}: ${fieldBuilder}`;

    // Chain methods: primaryKey, readOnly, notNull, entityId, comment
    if (isKeyField) {
      line += ".primaryKey()";
    }
    if (isReadOnly) {
      line += ".readOnly()";
    }
    // Only add .notNull() if explicitly marked as Nullable="false" in XML
    // Key fields are handled by primaryKey() which already makes them not null
    if (isExplicitlyNotNullable && !isKeyField) {
      line += ".notNull()";
    }
    if (metadata["@FieldID"]) {
      line += `.entityId(${JSON.stringify(metadata["@FieldID"])})`;
    }
    if (metadata["@FMComment"]) {
      line += `.comment(${JSON.stringify(metadata["@FMComment"])})`;
    }

    // Add comma if not the last field
    if (!isLastField) {
      line += ",";
    }

    fieldLines.push(line);
  }

  // Apply variableName override if provided, otherwise generate from entitySetName
  let varName = tableOverride?.variableName
    ? tableOverride.variableName.replace(/[^a-zA-Z0-9_]/g, "_")
    : entitySetName.replace(/[^a-zA-Z0-9_]/g, "_");
  // Prefix with underscore if name starts with a digit (invalid JavaScript identifier)
  if (/^\d/.test(varName)) {
    varName = `_${varName}`;
  }

  // Build options object
  const optionsParts: string[] = [];
  if (fmtId) {
    optionsParts.push(`entityId: ${JSON.stringify(fmtId)}`);
  }
  if (entityType["@FMComment"]) {
    optionsParts.push(`comment: ${JSON.stringify(entityType["@FMComment"])}`);
  }
  // Always include navigationPaths, even if empty
  const navPaths = navigationTargets.map((n) => JSON.stringify(n)).join(", ");
  optionsParts.push(`navigationPaths: [${navPaths}]`);

  const optionsSection =
    optionsParts.length > 0
      ? `, {\n${optionsParts.map((p) => `  ${p}`).join(",\n")}\n}`
      : "";

  const code = `export const ${varName} = fmTableOccurrence(${JSON.stringify(entitySetName)}, {
${fieldLines.join("\n")}
}${optionsSection});`;

  return {
    varName,
    code,
    navigation: navigationTargets,
    usedFieldBuilders,
    needsZod,
  };
}

/**
 * Generates import statements based on which field builders are used
 */
function generateImports(
  usedFieldBuilders: Set<string>,
  needsZod: boolean,
): string {
  const fieldBuilderImports: string[] = [];

  // Always need fmTableOccurrence
  fieldBuilderImports.push("fmTableOccurrence");

  // Add only the field builders that are actually used
  if (usedFieldBuilders.has("textField")) {
    fieldBuilderImports.push("textField");
  }
  if (usedFieldBuilders.has("numberField")) {
    fieldBuilderImports.push("numberField");
  }
  if (usedFieldBuilders.has("dateField")) {
    fieldBuilderImports.push("dateField");
  }
  if (usedFieldBuilders.has("timestampField")) {
    fieldBuilderImports.push("timestampField");
  }
  if (usedFieldBuilders.has("containerField")) {
    fieldBuilderImports.push("containerField");
  }

  const imports = [
    `import { ${fieldBuilderImports.join(", ")} } from "@proofkit/fmodata"`,
  ];

  if (needsZod) {
    imports.push(`import { z } from "zod/v4"`);
  }

  return imports.join(";\n") + ";\n";
}

/**
 * Sanitizes a name to be a safe filename
 */
function sanitizeFileName(name: string): string {
  const sanitized = name.replace(/[^a-zA-Z0-9_]/g, "_");
  // Prefix with underscore if name starts with a digit (invalid JavaScript identifier)
  return /^\d/.test(sanitized) ? `_${sanitized}` : sanitized;
}

/**
 * Generates TypeScript table occurrence files from parsed OData metadata.
 *
 * @param metadata - The parsed OData metadata
 * @param options - Generation options including output path
 * @returns Promise that resolves when all files have been generated
 */
export async function generateODataTypes(
  metadata: ParsedMetadata,
  config: FmodataConfig,
): Promise<void> {
  const { entityTypes, entitySets } = metadata;
  const { path, clearOldFiles = true, tables } = config;
  const outputPath = path ?? "schema";

  // Build a map from entity type name to entity set name
  const entityTypeToSetMap = new Map<string, string>();
  for (const [entitySetName, entitySet] of entitySets.entries()) {
    entityTypeToSetMap.set(entitySet.EntityType, entitySetName);
  }

  // Build a set of allowed table names from config
  const allowedTableNames = new Set<string>();
  if (tables) {
    for (const tableOverride of tables) {
      if (tableOverride?.tableName) {
        allowedTableNames.add(tableOverride.tableName);
      }
    }
  }

  // Build a table overrides map from the array for easier lookup
  const tableOverridesMap = new Map<
    string,
    NonNullable<FmodataConfig["tables"]>[number]
  >();
  if (tables) {
    for (const tableOverride of tables) {
      if (tableOverride?.tableName) {
        tableOverridesMap.set(tableOverride.tableName, tableOverride);
      }
    }
  }

  // Generate table occurrences for entity sets
  const generatedTOs: GeneratedTO[] = [];

  for (const [entitySetName, entitySet] of entitySets.entries()) {
    // Only generate types for tables specified in config
    if (allowedTableNames.size > 0 && !allowedTableNames.has(entitySetName)) {
      continue;
    }

    // Get table override config if it exists
    const tableOverride = tableOverridesMap.get(entitySetName);

    const entityType = entityTypes.get(entitySet.EntityType);
    if (entityType) {
      const generated = generateTableOccurrence(
        entitySetName,
        entityType,
        entityTypeToSetMap,
        tableOverride,
      );
      generatedTOs.push(generated);
    }
  }

  // Resolve and create output directory
  const resolvedOutputPath = resolve(outputPath);
  await mkdir(resolvedOutputPath, { recursive: true });

  if (clearOldFiles) {
    // Clear the directory if requested (but keep the directory itself)
    fs.emptyDirSync(resolvedOutputPath);
  }

  // Generate one file per table occurrence
  const exportStatements: string[] = [];

  for (const generated of generatedTOs) {
    const fileName = `${sanitizeFileName(generated.varName)}.ts`;
    const filePath = join(resolvedOutputPath, fileName);

    // Generate imports based on what's actually used in this file
    const imports = generateImports(
      generated.usedFieldBuilders,
      generated.needsZod,
    );

    const fileContent = `${imports}

${generated.code}
`;

    await writeFile(filePath, fileContent, "utf-8");

    // Collect export statement for index file
    exportStatements.push(
      `export { ${generated.varName} } from "./${sanitizeFileName(generated.varName)}";`,
    );
  }

  // Generate index.ts file that exports all table occurrences
  const indexContent = `// ============================================================================
// Auto-generated index file - exports all table occurrences
// ============================================================================

${exportStatements.join("\n")}
`;

  const indexPath = join(resolvedOutputPath, "index.ts");
  await writeFile(indexPath, indexContent, "utf-8");
}
